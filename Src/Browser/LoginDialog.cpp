#include "LoginDialog.h"
#include "PUID.h"
#include "EncryptByMd5.h"

#include <memory>

// 消息通知
void CLoginDialog::Notify(TNotifyUI& msg)
{     
     // 如为点击消息则通过控件名字判断是哪个控件
    if ( msg.sType == DUI_MSGTYPE_CLICK) {
        if( msg.pSender == static_cast<CButtonUI*>(m_paintMgr.FindControl(_T("minbtn"))) ) {
            SendMessage(WM_SYSCOMMAND, SC_MINIMIZE, 0);
		}
  
		else if( msg.pSender == static_cast<CButtonUI*>(m_paintMgr.FindControl(_T("closebtn"))) ) {
            // PostQuitMessage(0);
		}
  
		else if( msg.pSender == static_cast<CButtonUI*>(m_paintMgr.FindControl(_T("maxbtn"))) ) {
            ::IsZoomed(*this) ?
				SendMessage(WM_SYSCOMMAND, SC_RESTORE, 0) : 
				SendMessage(WM_SYSCOMMAND, SC_MAXIMIZE, 0);
		}

		else if (msg.pSender == static_cast<CButtonUI*>(m_paintMgr.FindControl(_T("loginbtn")))) {
			// Login();
			// PostQuitMessage(0);
        }
	}
	else if (msg.sType == DUI_MSGTYPE_RETURN) {
		// // 回车
		// Login();
		// PostQuitMessage(0);
	}
	// else if (msg.sType == DUI_MSGTYPE_ESCAPE) {
	//	// ESC
	//	PostQuitMessage(0);
	// }
}
  
// 首先启动消息循环会进入此虚函数进行消息处理
LRESULT CLoginDialog::HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == WM_KEYDOWN)
	{
		switch (wParam)
		{
		case VK_RETURN:                        // 回车建 
			// Login();
			// PostQuitMessage(0);
			break;
		case VK_ESCAPE:                        // ESC建 
			// PostQuitMessage(0);
			break;
		default:
			break;
		}
	}

    // 初始化消息映射MAP,利用auto_ptr维护指针,static保证只创建一次
    static std::auto_ptr<MessageMap> customMessageMap(InitMessageMap());
  
    BOOL bHandled = TRUE;
    LRESULT lRes = 0;
  
    // 将消息在消息映射map中进行查找 找到响应的消息处理函数
    if ( customMessageMap->find(uMsg) != customMessageMap->end() ) {
        // typedef HRESULT (CLoginDialog::*CustomMsgHandler)(WPARAM, LPARAM, BOOL&);
        // 如果找到,查找相应的消息响应函数
        CustomMsgHandler handler = (*customMessageMap)[uMsg];
        // 通过this->(*handler)进行消息响应函数的调用
        lRes = (this->*handler)(wParam, lParam, bHandled);
        // 如果bHandled返回True没有被修改那么说明消息已经被处理,返回
		if (bHandled) { return lRes; }
    }
    // CPaintManagerUI丢给PaintManagerUI进行处理
	// 如果处理了返回True,否则返回false继续走
	if (m_paintMgr.MessageHandler(uMsg, wParam, lParam, lRes)) { return lRes; }
    // 最后丢给默认的windows消息处理函数
    return CWindowWnd::HandleMessage(uMsg, wParam, lParam);
}
  
// 初始化消息循环对应的消息响应函数
CLoginDialog::MessageMap* CLoginDialog::InitMessageMap()
{
    MessageMap* map = new MessageMap;
    (*map)[WM_CREATE] = &CLoginDialog::OnCreate;
    (*map)[WM_DESTROY] = &CLoginDialog::OnDestory;
    (*map)[WM_ERASEBKGND] = &CLoginDialog::OnErasebkgnd;
    (*map)[WM_NCPAINT] = &CLoginDialog::OnNcPaint;
    // 以下三个消息用于屏蔽系统标题栏
    (*map)[WM_NCACTIVATE] = &CLoginDialog::OnNcActive;
    (*map)[WM_NCCALCSIZE] = &CLoginDialog::OnNcCalcSize;
    (*map)[WM_NCHITTEST] = &CLoginDialog::OnNcHit;
    (*map)[WM_SYSCOMMAND] = &CLoginDialog::OnSysCommand;
    return map;
}
  
// 窗口创建时候
HRESULT CLoginDialog::OnCreate( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // 获取当前窗口风格
    LONG styleValue = ::GetWindowLong(*this, GWL_STYLE);
    styleValue &= ~WS_CAPTION;
    // 设置STYLE
    ::SetWindowLong(*this, GWL_STYLE, styleValue | WS_CLIPSIBLINGS | WS_CLIPCHILDREN);
    // 初始化界面渲染器
	m_paintMgr.Init(m_hWnd);

	CDialogBuilder builder;
    // 通过xml以及渲染器渲染界面UI
    CControlUI* pRoot = builder.Create(_T("Skin\\logindlg.xml"), (UINT)0, NULL, &m_paintMgr);
    // 附加界面UI到对话框容器
	m_paintMgr.AttachDialog(pRoot);
    // 增加消息处理,因为实现了INotifyUI接口
	m_paintMgr.AddNotifier(this);

	// 业务相关初始化
	// Init();

    return 0;
}
  
HRESULT CLoginDialog::OnDestory( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // 发送退出消息
    // ::PostQuitMessage(0L);
    return 0;
}
  
// 擦除背景
HRESULT CLoginDialog::OnErasebkgnd( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    return 1;
}
  
HRESULT CLoginDialog::OnNcPaint( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    return 0;
}
  
HRESULT CLoginDialog::OnNcActive( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	if (::IsIconic(*this)) { bHandled = FALSE; }
    return (wParam == 0) ? TRUE : FALSE;
}
  
// 如果不处理那么就会导致DUILIB不停调用系统消息进行处理
// 屏蔽系统标题栏 似乎不屏蔽一定会出问题
HRESULT CLoginDialog::OnNcCalcSize( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    return 0;
}
  
HRESULT CLoginDialog::OnNcHit( WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    return HTCLIENT;
}
  
// 系统命令处理
LRESULT CLoginDialog::OnSysCommand(WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( wParam == SC_CLOSE ) {
        // ::PostQuitMessage(0L);
        bHandled = TRUE;
        return 0;
    }
  
    BOOL bZoomed = ::IsZoomed(*this);
    LRESULT lRes = CWindowWnd::HandleMessage(WM_SYSCOMMAND, wParam, lParam);
  
    return 1L;
}  

// 窗口初始化动作
void CLoginDialog::Init() {
	CPUID* hdInfoTool = new CPUID();

	// 获取CPU序列号
	// CStdString cpuSn = hdInfoTool->GetCpuSerialNumber();
	CStdString cpuSn = hdInfoTool->GetCpuSn();
	// 获取硬盘序列号
	CStdString hdSn = hdInfoTool->getHDSerialNum();
	// 获取硬盘型号
	CStdString hdMod = hdInfoTool->getHDModelNum();
	// 获取路由Mac
	CStdString routeMac = hdInfoTool->getRouteMac();
	// 获取本机Mac
	CStdString localMac = hdInfoTool->GetMacInfo();

	// 硬盘序列号
	CTextUI* pTextHdSn = (CTextUI*)m_paintMgr.FindControl(_T("editHdSn"));
	if(NULL != pTextHdSn) {
	    pTextHdSn->SetText(hdSn);
	}

	// 硬盘型号
	CTextUI* pTextHdMod = (CTextUI*)m_paintMgr.FindControl(_T("editHdMod"));
	if (NULL != pTextHdMod) {
		pTextHdMod->SetText(hdMod);
	}

	// CPU序列号
	CTextUI* pTextCpuId = (CTextUI*)m_paintMgr.FindControl(_T("editCPUID"));
	if (NULL != pTextCpuId) {
		pTextCpuId->SetText(cpuSn);
	}

	// 路由器MAC
	CTextUI* pTextRouteMac = (CTextUI*)m_paintMgr.FindControl(_T("editRouteMac"));
	if (NULL != pTextRouteMac) {
		pTextRouteMac->SetText(routeMac);
	}

	// 本机MAC
	CTextUI* pTextLocalMac = (CTextUI*)m_paintMgr.FindControl(_T("editLocalMac"));
	if (NULL != pTextLocalMac) {
		pTextLocalMac->SetText(localMac);
	}
}

// 登录
void CLoginDialog::Login() {
	TCHAR szFilePath[MAX_PATH];

	GetModuleFileName(NULL, szFilePath, _MAX_PATH);
	CStdString strRunDir = szFilePath;
	int nPos = strRunDir.ReverseFind('\\');
	if (nPos != -1) { strRunDir = strRunDir.Left(nPos + 1); }

	CStdString strIniFilePath = CStdString(strRunDir).append(_T("myie.ini"));

	// 从INI文件中读取配置：登录url
	CStdString strLogInUrl;
	::GetPrivateProfileString(
		_T("Settings"),
		_T("url"),
		_T(""),
		strLogInUrl.GetBuffer(MAX_PATH),
		MAX_PATH,
		strIniFilePath);

	// 从INI文件中读取配置：是否显示地址栏
	CStdString strAddrInNewWin;
	::GetPrivateProfileString(
		_T("Bands"),
		_T("band3"),
		_T("0"),
		strAddrInNewWin.GetBuffer(MAX_PATH),
		MAX_PATH,
		strIniFilePath);

	// 从INI文件中读取配置：版本号
	CStdString strVersion;
	::GetPrivateProfileString(
		_T("Settings"),
		_T("Version"),
		_T("500"),
		strVersion.GetBuffer(MAX_PATH),
		MAX_PATH,
		strIniFilePath);

	// 从INI文件中读取配置：机器码长短模式
	CStdString strMachineCodeMode;
	::GetPrivateProfileString(
		_T("Settings"),
		_T("MachineCodeMode"),
		_T("1"),
		strMachineCodeMode.GetBuffer(MAX_PATH),
		MAX_PATH,
		strIniFilePath);

	CTextUI* pTextUserName = (CTextUI*)m_paintMgr.FindControl(_T("editUserName"));
	CStdString strUserName = pTextUserName->GetText();

	CTextUI* pTextPassword = (CTextUI*)m_paintMgr.FindControl(_T("editPassword"));
	CStdString strPassword = pTextPassword->GetText();

	CStdString strChromePath = CStdString(strRunDir).append(_T("ChromePortable\\ChromePortable.exe"));
	CStdString strMachineCode = CalcMachineCode(strVersion, strMachineCodeMode);

	CStdString strUrl(_T(""));
	strUrl.Format(_T("%s%s?username=%s&password=%s&key=%s&version=%s&type=1"),
		strAddrInNewWin.CompareNoCase(_T("1")) == 0 ? _T("") : _T("--app="),
		strLogInUrl.GetBuffer(),
		strUserName.GetBuffer(),
		strPassword.GetBuffer(),
		strMachineCode.GetBuffer(),
		strVersion.CompareNoCase(_T("500")) == 0 ? _T("3.3") : _T("3.2"));

	ShellExecute(NULL,
		_T("open"),
		strChromePath,
		strUrl,
		NULL,
		SW_SHOWMAXIMIZED);
}

// 计算机器码
CStdString CLoginDialog::CalcMachineCode(
	    CStdString version, 
	    CStdString machineCodeMode) {
	CPUID* hdInfoTool = new CPUID();

	// 获取CPU序列号
	CStdString cpuSn = hdInfoTool->GetCpuSn();
	// 获取硬盘序列号
	CStdString hdSn = hdInfoTool->getHDSerialNum();
	// 获取硬盘型号
	CStdString hdMod = hdInfoTool->getHDModelNum();
	// 获取路由Mac
	CStdString routeMac = hdInfoTool->getRouteMac();

	if (version.CompareNoCase(_T("500")) == 0) {
		// 3.3
		CStdString strHdInfo(_T(""));
		strHdInfo.append(hdSn);
		if (hdMod.GetLength() > 4) {
			strHdInfo.append(hdMod.Left(3));
		}

		CStdString strCpuSnHdInfo(_T(""));
		strCpuSnHdInfo.Format(_T("@%s@%s"),
			cpuSn.GetBuffer(),
			strHdInfo.GetBuffer());

		CStdString strMd5Part1 = CEncryptByMd5::Digest(strCpuSnHdInfo);
		CStdString strMd5Part2 = CEncryptByMd5::Digest(routeMac);
		return strMd5Part1.append(strMd5Part2);
	}
	else if (version.CompareNoCase(_T("400")) == 0) {
		// 3.2
		if (machineCodeMode.CompareNoCase(_T("1")) == 0) {
			// 长机器码模式
			CStdString strHdInfo(_T(""));
			strHdInfo.append(hdSn);
			if (hdMod.GetLength() > 4) {
				strHdInfo.append(hdMod.Left(3));
			}

			CStdString strMachinePlainCode(_T(""));
			strMachinePlainCode.Format(_T("@%s%s"),
				strHdInfo.GetBuffer(),
				routeMac.GetBuffer());

			return CEncryptByMd5::Digest(strMachinePlainCode);
		}
		else {
			// 短机器码模式
			CStdString strHdInfo(_T(""));
			strHdInfo.append(hdSn);
			if (hdMod.GetLength() > 4) {
				strHdInfo.append(hdMod.Left(3));
			}

			CStdString strMachinePlainCode(_T(""));
			strMachinePlainCode.Format(_T("@%s"),
				strHdInfo.GetBuffer());

			return CEncryptByMd5::Digest(strMachinePlainCode);
		}
	}
}